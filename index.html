<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  <title>Knife Engraving Customiser</title>
  <link rel="icon" type="image/x-icon" href="./favicon.ico">

  <!-- fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Lobster&family=Roboto&display=swap" rel="stylesheet">

  <style>
    :root {
      --accent: #d00024;
      --gray: #888;
      --bg: #fafafa;
      --border: #ddd;
      --pad: 1rem;
      --radius: .5rem;
    }
    * { box-sizing: border-box; margin: 0; }
    body {
      font-family: Roboto, Arial, sans-serif;
      background: var(--bg);
      color: #222;
    }
    h1,h2,h3 { text-align:center; margin:1rem 0; }
    .container {
      max-width:1200px; margin:auto; padding:var(--pad);
      display:flex; flex-direction:column; gap:var(--pad);
    }
    .section {
      background:#fff; border:1px solid var(--border);
      border-radius:var(--radius); padding:var(--pad);
    }
    #product-picker {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(120px,1fr));
      gap:.75rem;
    }
    .product-option {
      display:flex; flex-direction:column; align-items:center;
    }
    .product-option input {
      margin-bottom:.5rem;
      cursor:pointer;
    }
    .controls {
      display:flex; flex-wrap:wrap; gap:1rem; align-items:center;
    }
    .controls label { font-size:.9rem; margin-right:.25rem; }
    button {
      background:var(--accent); color:#fff; border:none;
      padding:.6rem 1rem; border-radius:var(--radius);
      cursor:pointer; font-weight:600;
    }
    button[disabled] {
      opacity:.4; cursor:not-allowed;
    }
    .canvas-wrapper {
      position:relative;
      width:100%; border:1px solid var(--border);
      border-radius:var(--radius); background:#eaeaea;
      touch-action:none; margin:auto;
    }
    canvas {
      display:block; touch-action:none;
    }
    .loadingOverlay {
      position:absolute; inset:0;
      background:rgba(255,255,255,0.85);
      display:flex; align-items:center; justify-content:center;
      font-size:1.5rem; color:#555;
      visibility:hidden; z-index:10;
    }
    .bbox {
      position:absolute; border:1px dashed #000;
      pointer-events:none; display:none;
    }
    .handle {
      position:absolute; width:10px; height:10px;
      background:#fff; border:1px solid #000;
      pointer-events:auto;
    }
    .handle[data-handle="nw"]{ top:-5px; left:-5px; cursor:nwse-resize;}
    .handle[data-handle="ne"]{ top:-5px; right:-5px; cursor:nesw-resize;}
    .handle[data-handle="sw"]{ bottom:-5px; left:-5px; cursor:nesw-resize;}
    .handle[data-handle="se"]{ bottom:-5px; right:-5px; cursor:nwse-resize;}
    @media(max-width:600px){
      .controls { flex-direction:column; align-items:flex-start; }
    }
    #backBtn { background:var(--gray); margin-bottom:1rem; }
  </style>
</head>
<body>
  <h1>Knife Engraving Customiser</h1>
  <div class="container">

    <!-- STEP 1: SELECT KNIVES -->
    <div id="selectionSection" class="section">
      <h2>1. Which knives did you buy?</h2>
      <div id="product-picker">
        <label class="product-option">
          <input type="checkbox" value="chef.jpg" data-id="chef" data-name="Chef Knife" data-size="big">
          <img src="chef-thumb.jpg" alt="Chef knife"><span>Chef</span>
        </label>
        <label class="product-option">
          <input type="checkbox" value="santoku.jpg" data-id="santoku" data-name="Santoku Knife" data-size="big">
          <img src="santoku-thumb.jpg" alt="Santoku knife"><span>Santoku</span>
        </label>
        <label class="product-option">
          <input type="checkbox" value="bread.jpg" data-id="bread" data-name="Bread Knife" data-size="big">
          <img src="bread-thumb.jpg" alt="Bread knife"><span>Bread</span>
        </label>
        <label class="product-option">
          <input type="checkbox" value="chopper.jpg" data-id="chopper" data-name="Chopper Knife" data-size="big">
          <img src="chopper-thumb.jpg" alt="Chopper knife"><span>Chopper</span>
        </label>
        <label class="product-option">
          <input type="checkbox" value="utility.jpg" data-id="utility" data-name="Utility Knife" data-size="small">
          <img src="utility-thumb.jpg" alt="Utility knife"><span>Utility</span>
        </label>
        <label class="product-option">
          <input type="checkbox" value="paring.jpg" data-id="paring" data-name="Paring Knife" data-size="small">
          <img src="paring-thumb.jpg" alt="Paring knife"><span>Paring</span>
        </label>
      </div>
      <div style="text-align:center; margin-top:1rem;">
        <button id="toCustomizeBtn" disabled>Next: Customize</button>
      </div>
    </div>

    <!-- EDITOR: SETTINGS + CANVASES -->
    <div id="editorSection" style="display:none;">
      <button id="backBtn">← Back to selection</button>
      <div class="section">
        <h2>Customize & Settings</h2>
        <div class="controls">
          <label><input type="checkbox" id="useSameContent" checked> Use same text & font for all knives</label>
        </div>
        <div id="globalControls" class="controls" style="margin-top:1rem;">
          <div><label>Text:</label><input type="text" id="globalText" placeholder="Enter engraving"></div>
          <div><label>Font:</label>
            <select id="globalFont">
              <option value="Montserrat">Montserrat</option>
              <option value="Roboto">Roboto</option>
              <option value="Lobster">Lobster</option>
              <option value="'Times New Roman',serif">Times New Roman</option>
              <option value="Courier New">Courier New</option>
              <option value="Arial">Arial</option>
            </select>
          </div>
          <button id="alignBtn">Align Content</button>
        </div>
      </div>
      <div id="knifeSections" class="container"></div>
      <div style="text-align:center; margin:1rem 0;">
        <button id="downloadZipBtn">Generate & Download ZIP</button>
      </div>
    </div>

  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.7.1/dist/jszip.min.js"></script>
  <script>
  (function(){
    const baseFont = 150;
    const ALL_KNIVES = [
      { id:"chef",    name:"Chef Knife",    src:"chef.jpg",    size:"big"   },
      { id:"santoku", name:"Santoku Knife", src:"santoku.jpg", size:"big"   },
      { id:"bread",   name:"Bread Knife",   src:"bread.jpg",   size:"big"   },
      { id:"chopper", name:"Chopper Knife", src:"chopper.jpg", size:"big"   },
      { id:"utility", name:"Utility Knife", src:"utility.jpg", size:"small" },
      { id:"paring",  name:"Paring Knife",  src:"paring.jpg",  size:"small" }
    ];

    let selected = [];
    const toCustomizeBtn = document.getElementById('toCustomizeBtn');
    const backBtn        = document.getElementById('backBtn');
    const selectionSec   = document.getElementById('selectionSection');
    const editorSec      = document.getElementById('editorSection');
    const knifeSections  = document.getElementById('knifeSections');
    const useSame        = document.getElementById('useSameContent');
    const globalText     = document.getElementById('globalText');
    const globalFont     = document.getElementById('globalFont');
    const alignBtn       = document.getElementById('alignBtn');
    const downloadZipBtn = document.getElementById('downloadZipBtn');

    function loadImage(src){ return new Promise(r=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>r(i); i.src=src; }); }

    // enable Next when any knife selected
    document.querySelectorAll('#product-picker input[type=checkbox]').forEach(chk=>{
      chk.addEventListener('change', ()=>{
        toCustomizeBtn.disabled = ![...document.querySelectorAll('#product-picker input[type=checkbox]')].some(c=>c.checked);
      });
    });

    toCustomizeBtn.addEventListener('click', ()=>{
      selectionSec.style.display = 'none';
      editorSec.style.display    = '';
      initEditors();
      window.scrollTo(0,0);
    });
    backBtn.addEventListener('click', ()=>{
      editorSec.style.display    = 'none';
      selectionSec.style.display = '';
      knifeSections.innerHTML = '';
      selected = [];
    });

    function initEditors(){
      // build selected array
      selected = [...document.querySelectorAll('#product-picker input[type=checkbox]:checked')].map(chk=>{
        const id = chk.dataset.id;
        const def = ALL_KNIVES.find(k=>k.id===id);
        return {
          ...def,
          text:   globalText.value,
          font:   globalFont.value,
          textScale:1,
          baseDims:{w:0,h:0},
          pos:{x:0,y:0},
          pointers:{}, pinch:false
        };
      });
      knifeSections.innerHTML = '';
      selected.forEach(kn=>makeSection(kn));
    }

    function makeSection(kn){
      const sec = document.createElement('div');
      sec.className = 'section';
      sec.innerHTML = `
        <h3>${kn.name}</h3>
        <div class="controls localControls" style="justify-content:center; gap:1rem; margin-bottom:1rem;">
          <div><label>Text:</label><input type="text" class="txtInput" value="${kn.text}"></div>
          <div><label>Font:</label>
            <select class="fontSelect">
              <option value="Montserrat">Montserrat</option>
              <option value="Roboto">Roboto</option>
              <option value="Lobster">Lobster</option>
              <option value="'Times New Roman',serif">Times New Roman</option>
              <option value="Courier New">Courier New</option>
              <option value="Arial">Arial</option>
            </select>
          </div>
        </div>
        <div class="canvas-wrapper" id="wrap-${kn.id}">
          <canvas id="view-${kn.id}"></canvas>
          <div id="loading-${kn.id}" class="loadingOverlay">Loading…</div>
          <div id="bbox-${kn.id}" class="bbox">
            <div class="handle" data-handle="nw"></div>
            <div class="handle" data-handle="ne"></div>
            <div class="handle" data-handle="sw"></div>
            <div class="handle" data-handle="se"></div>
          </div>
        </div>`;
      knifeSections.appendChild(sec);
      const txtInput = sec.querySelector('.txtInput');
      const fontSel  = sec.querySelector('.fontSelect');
      fontSel.value = kn.font;
      initCanvas(kn, txtInput, fontSel);
      updateLocalVisibility();
    }

    function updateLocalVisibility(){
      const showLocal = !useSame.checked;
      document.querySelectorAll('.localControls').forEach(el=>{
        el.style.display = showLocal ? 'flex' : 'none';
      });
    }

    useSame.addEventListener('change', ()=>{
      updateLocalVisibility();
      // if switching to same, override each knife
      if(useSame.checked){
        selected.forEach(kn=>{
          kn.text = globalText.value;
          kn.font = globalFont.value;
          kn.textScale = 1;
          if (kn._full) {
            kn.baseDims = measureText(kn);
            kn.pos.x = kn._full.width/2 - kn.baseDims.w/2;
            kn.pos.y = kn._full.height/2 - kn.baseDims.h/2;
          }
          kn.draw();
        });
      }
    });

    globalText.addEventListener('input', ()=>{
      if(!useSame.checked) return;
      selected.forEach(kn=>{
        kn.text = globalText.value;
        kn.textScale = 1;
        kn.baseDims = measureText(kn);
        kn.pos.x = kn._full.width/2 - kn.baseDims.w/2;
        kn.pos.y = kn._full.height/2 - kn.baseDims.h/2;
        kn.draw();
      });
    });
    globalFont.addEventListener('input', ()=>{
      if(!useSame.checked) return;
      selected.forEach(kn=>{
        kn.font = globalFont.value;
        kn.textScale = 1;
        kn.baseDims = measureText(kn);
        kn.pos.x = kn._full.width/2 - kn.baseDims.w/2;
        kn.pos.y = kn._full.height/2 - kn.baseDims.h/2;
        kn.draw();
      });
    });

    alignBtn.addEventListener('click', ()=>{
      ['big','small'].forEach(size=>{
        const grp = selected.filter(k=>k.size===size);
        if(grp.length<2) return;
        const refX = grp[0].pos.x;
        grp.slice(1).forEach(k=>{ k.pos.x = refX; });
      });
      selected.forEach(k=>k.draw());
    });

    function measureText(kn){
      const ctx = kn._fCtx;
      ctx.font = `${baseFont}px ${kn.font}`;
      const w = ctx.measureText(kn.text).width;
      return { w, h: baseFont };
    }

    function initCanvas(kn, txtInput, fontSel){
      const wrap    = document.getElementById(`wrap-${kn.id}`);
      const view    = document.getElementById(`view-${kn.id}`);
      const overlay = document.getElementById(`loading-${kn.id}`);
      const bbox    = document.getElementById(`bbox-${kn.id}`);
      const handles = bbox.querySelectorAll('.handle');
      const vCtx    = view.getContext('2d');
      const full    = document.createElement('canvas');
      const fCtx    = full.getContext('2d');

      kn._view    = view;
      kn._vCtx    = vCtx;
      kn._full    = full;
      kn._fCtx    = fCtx;
      kn._overlay = overlay;
      kn._bbox    = bbox;
      kn._handles = handles;

      function showOverlay(on){
        overlay.style.visibility = on ? 'visible' : 'hidden';
      }
      function fit(){
        const w = wrap.clientWidth;
        const scale = kn._img.naturalWidth ? w / kn._img.naturalWidth : 1;
        view.width  = kn._img.naturalWidth * scale;
        view.height = kn._img.naturalHeight * scale;
        full.width  = kn._img.naturalWidth;
        full.height = kn._img.naturalHeight;
      }
      function toFull(cx,cy){
        const r = view.getBoundingClientRect();
        return {
          x: (cx - r.left) * (full.width/r.width),
          y: (cy - r.top ) * (full.height/r.height)
        };
      }
      function hitTest(x,y){
        return x>=kn.pos.x && x<=kn.pos.x+kn.baseDims.w*kn.textScale
            && y>=kn.pos.y && y<=kn.pos.y+kn.baseDims.h*kn.textScale;
      }
      function draw(){
        // full‐res
        fCtx.clearRect(0,0,full.width,full.height);
        fCtx.drawImage(kn._img,0,0);
        fCtx.font = `${baseFont*kn.textScale}px ${kn.font}`;
        fCtx.fillStyle='#000'; fCtx.textBaseline='top';
        fCtx.fillText(kn.text, kn.pos.x, kn.pos.y);

        // preview
        const s = view.width/full.width;
        vCtx.setTransform(s,0,0,s,0,0);
        vCtx.clearRect(0,0,full.width,full.height);
        vCtx.drawImage(kn._img,0,0);
        vCtx.font = `${baseFont*kn.textScale}px ${kn.font}`;
        vCtx.fillStyle='#000'; vCtx.textBaseline='top';
        vCtx.fillText(kn.text, kn.pos.x, kn.pos.y);
        vCtx.setTransform(1,0,0,1,0,0);

        // bbox
        const dx = view.width/full.width, dy=view.height/full.height;
        if(kn.text){
          bbox.style.display='block';
          bbox.style.width  = (kn.baseDims.w*kn.textScale*dx)+'px';
          bbox.style.height = (kn.baseDims.h*kn.textScale*dy)+'px';
          bbox.style.left   = (kn.pos.x*dx)+'px';
          bbox.style.top    = (kn.pos.y*dy)+'px';
        } else {
          bbox.style.display='none';
        }
      }
      kn.draw = draw;

      // load image
      showOverlay(true);
      loadImage(kn.src).then(img=>{
        kn._img = img;
        fit();
        kn.baseDims = measureText(kn);
        kn.textScale = 1;
        kn.pos.x = full.width/2 - kn.baseDims.w/2;
        kn.pos.y = full.height/2 - kn.baseDims.h/2;
        draw();
        showOverlay(false);
      });

      // local controls
      txtInput.addEventListener('input', e=>{
        kn.text = e.target.value;
        kn.baseDims = measureText(kn);
        kn.textScale = 1;
        kn.pos.x = full.width/2 - kn.baseDims.w/2;
        kn.pos.y = full.height/2 - kn.baseDims.h/2;
        draw();
      });
      fontSel.addEventListener('input', e=>{
        kn.font = e.target.value;
        kn.baseDims = measureText(kn);
        kn.textScale = 1;
        kn.pos.x = full.width/2 - kn.baseDims.w/2;
        kn.pos.y = full.height/2 - kn.baseDims.h/2;
        draw();
      });

      // drag/resize/pinch
      let dragging=false, dragStart={}, resizing=false, resizeStart={};
      view.addEventListener('pointerdown', e=>{
        const f = toFull(e.clientX,e.clientY);
        if(!hitTest(f.x,f.y) || resizing || kn.pinch) return;
        dragging = true;
        dragStart = { id:e.pointerId, dx:f.x-kn.pos.x, dy:f.y-kn.pos.y };
        e.preventDefault();
      });
      window.addEventListener('pointermove', e=>{
        if(!dragging||e.pointerId!==dragStart.id) return;
        const f=toFull(e.clientX,e.clientY);
        kn.pos.x = f.x-dragStart.dx;
        kn.pos.y = f.y-dragStart.dy;
        draw();
      });
      ['pointerup','pointercancel'].forEach(evt=>
        window.addEventListener(evt,e=>{ if(e.pointerId===dragStart.id) dragging=false; })
      );

      handles.forEach(h=>{
        h.addEventListener('pointerdown', e=>{
          e.stopPropagation();
          resizing=true;
          const box = bbox.getBoundingClientRect();
          const center = toFull(box.left+box.width/2, box.top+box.height/2);
          const p0 = toFull(e.clientX,e.clientY);
          resizeStart = {
            id: e.pointerId,
            cx: center.x, cy: center.y,
            scale: kn.textScale,
            d0: Math.hypot(p0.x-center.x, p0.y-center.y)
          };
        });
      });
      window.addEventListener('pointermove', e=>{
        if(!resizing||e.pointerId!==resizeStart.id) return;
        const p = toFull(e.clientX,e.clientY);
        const d = Math.hypot(p.x-resizeStart.cx, p.y-resizeStart.cy);
        kn.textScale = resizeStart.scale*(d/resizeStart.d0);
        kn.pos.x = resizeStart.cx - (kn.baseDims.w*kn.textScale)/2;
        kn.pos.y = resizeStart.cy - (kn.baseDims.h*kn.textScale)/2;
        draw();
      });
      ['pointerup','pointercancel'].forEach(evt=>
        window.addEventListener(evt,e=>{ if(e.pointerId===resizeStart.id) resizing=false; })
      );

      view.addEventListener('pointerdown', e=>{
        kn.pointers[e.pointerId] = { x:e.clientX, y:e.clientY };
        if(Object.keys(kn.pointers).length===2 && !dragging && !resizing){
          kn.pinch = true;
          const [a,b] = Object.values(kn.pointers);
          const fA = toFull(a.x,a.y), fB = toFull(b.x,b.y);
          kn.pinchStart = {
            scale: kn.textScale,
            cx: (fA.x+fB.x)/2, cy: (fA.y+fB.y)/2,
            d0: Math.hypot(fA.x-fB.x,fA.y-fB.y)
          };
        }
      });
      view.addEventListener('pointermove', e=>{
        if(!kn.pinch||!(e.pointerId in kn.pointers)) return;
        kn.pointers[e.pointerId] = { x:e.clientX, y:e.clientY };
        const [a,b] = Object.values(kn.pointers);
        const fA = toFull(a.x,a.y), fB = toFull(b.x,b.y);
        const d1 = Math.hypot(fA.x-fB.x,fA.y-fB.y);
        kn.textScale = kn.pinchStart.scale*(d1/kn.pinchStart.d0);
        kn.pos.x = kn.pinchStart.cx - (kn.baseDims.w*kn.textScale)/2;
        kn.pos.y = kn.pinchStart.cy - (kn.baseDims.h*kn.textScale)/2;
        draw();
      });
      ['pointerup','pointercancel'].forEach(evt=>
        view.addEventListener(evt,e=>{ delete kn.pointers[e.pointerId]; if(Object.keys(kn.pointers).length<2) kn.pinch=false; })
      );
    }

    // ZIP download
    downloadZipBtn.addEventListener('click', ()=>{
      const zip = new JSZip();
      const folder = zip.folder('engravings');
      Promise.all(selected.map(kn=>{
        return new Promise(res=>{
          kn._full.toBlob(blob=>{
            folder.file(`${kn.id}.png`, blob);
            res();
          });
        });
      })).then(()=>{
        zip.generateAsync({type:'blob'}).then(content=>{
          const url = URL.createObjectURL(content);
          const a = document.createElement('a');
          a.href = url; a.download = 'engravings.zip';
          document.body.appendChild(a);
          a.click();
          setTimeout(()=>{
            URL.revokeObjectURL(url);
            a.remove();
          },100);
        });
      });
    });
  })();
  </script>
</body>
</html>
